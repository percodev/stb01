Логика формирования событий такая:
1. Изменение состояния контроллера - событие формируется.
2. Далее оно сохраняется в БД.
3. После сохранения оно пересылается по всем открытым сокетам, если соответствует условиям фильтрации, в виде: 
{"event":{"id":40140,"date":1629967880,"timezone_offset":-10800,"code":4,"category":1, "number":0}}
Событие будет передано по конкретному сокету, если установлен фильтр вида:
{"set":"event_acl","event_acl":[{"code":1,"allow":true},{"code":4,"allow":true},{"allow":false}]}
(Здесь фильтр установлен на приём событий с кодами 1 и 4, остальные пересылаться не будут).

Т.е. сторонний софт после открытия соединения и авторизации, если хочет принимать определённые события асинхронно (без запроса, в момент их формирования), должен передать кадр "set":"event_acl". Для приёма всего, без разбора, следующий кадр - {"set": "event_acl", "event_acl": [{"allow":"true"}]}.

Вариант работы по событиям:
1. Подключение.
2. Авторизация. (попытка установки фильтра п.3 -> требование авторизации -> авторизация)
3. Установка фильтра.
4. Запрос событий, и сохранение их в собственной БД.
5. Запрос состояния.
6. Далее, любое изменение состояния контроллера будет сопровождаться формированием (соответствующего этому изменению) события. Контроллер передаёт это событие асинхронно.

Пример пп. 2,3,6:
софт -> {"set": "event_acl", "event_acl": [{"allow": "true"}]}
контроллер -> {"event":"need_auth","need_auth":{"salt":"qewarvhn"}}
софт -> {"set":"auth","auth":{"hash":"65ccf195f4983bb4951bbf38f58da071"}}
контроллер -> {"answer":{"auth":"ok","set":"own"},"auth":{"hash":"65ccf195f4983bb4951bbf38f58da071"}}
софт -> {"set": "event_acl", "event_acl": [{"allow": "true"}]}	// Вот здесь повтор запроса после успешной авторизации!
контроллер -> {"answer":{"event_acl":"ok","set":"own"},"event_acl":[{"allow":"true"}]}
.....
{"event":{"id":151449,"date":1744284422,"code":103,"category":1,"number":1}}

# Установка фильтра принимаемых событий.
## Установка:

События формируемые контроллером могут передаваться асинхронно, в момент формирования (в дополнение к получению событий по запросу). Для получения асинхронных событий надо настроить фильтры `event_acl`.
Внутри фильтра все поля объединяются по «И», фильтры объединяются по «ИЛИ».
Параметры фильтра совпадают с полями событий. Событие перед отправкой проходит через все фильтры до того, который его пропускает.

```json
{
	"set": "event_acl",
	"event_acl": [	
            {
                "allow":"true",
                "category":"0",
                "number":"1",
            },
            {
                "allow":"false"
            }
	]
}
```
## Ответ:
```json
{
    "answer":{"event_acl":"ok","set":"own"},
    "event_acl": [	
        {
            "allow":"true",
            "category":"0",
            "number":"1",
        },
        {
            "allow":"false"
        }
    ]
}
```
# Количество событий.
## Запрос:
```json
{
    "get":"event_count"
}
```

## Ответ:
```json
{
    "answer":{"event_count":"ok"},
    "event_count":{"value":150001}
}
```  

# Получение событий.
## Запрос:
```json
{
    "get":"event",
    "event" : {
        "limit":1,
        "offset":0,
        "category":["0","1","2","3","4","5"],
        "code":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],
        "start":-10800,
        "stop":2082747540
    }
}
```
## Ответ:
```json
{
    "answer":{"event":"ok"},
    "event":{
        "id":40140,
        "date":1629967880,
        "timezone_offset":-10800,
        "code":102,
        "category":1,
        "number":0
    }
}

{
    "answer":{"event":"ok"},
    "event":{
        "id":40140,
        "date":1629967880,
        "timezone_offset":-10800,
        "code":4,
        "category":1,
        "number":0
    }
}
```

# Удаление событий.
## Запрос:
```json
{
    "control":"event",
    "event" : {}
}
```
## Ответ:
```json
{
    "result":{"event":"ok"},
    "event":{ }
}
```
`allow` — Пропуск события через фильтр
		`true` - да
		`false` - нет 

`limit` — Ограничение событий в выборке 1 — 20

`offset` — Сдвиг выборки событий относительно 1-го (самого позднего)  события 0 — 4294967295

`start`/`stop` — Начало/конец диапазона в сек от 01.01.1970 (включительно)

`start_id`/`stop_id` — Начало/конец диапазона по id событий  (включительно)

`done` — Необязательный параметр запроса. Признак окончания передачи событий в ответ на запрос. Если в запросе выставлен в `true`, то после последнего переданного контроллером события будет дополнительны кадр с объектом {`done`:`true`}.

`date` — Дата в секундах с 1970 г по 2038 г(точность до 1 секунды)

`timezone_offset` — Сдвиг временной зоны относительно UTC в с. на момент формирования события (точность до 1 секунды) (Значение -10800, например, соответствует временной зоне GMT+3)

`category` — Категория : 0 — 6

`code` — Код события  :  0 — ?
	
`number` — Номер ресурса : 0 — ?


# Коды событий


96	Проход по команде от ДУ

97	Проход по команде от оператора ПК

99	Несанкционированный проход через ИУ (взлом ИУ)

102	ИУ разблокирован

103	ИУ заблокирован

160	Активизация входа

161	Нормализация входа

162	Активизация выхода

163	Нормализация выхода

164	Активизация входа FireAlarm

165	Нормализация входа FireAlarm

176	Включение питания контроллера

177	Выключение питания контроллера

178	Перезапуск контроллера

183	Очистка событий журнала регистрации

201	Перезапуск приложения stb01


300	Восстановление связи с платой MAIN

301	Нарушение связи с платой MAIN

320	Ошибка инициализации датчиков (перекрытие по старту)

321	Восстановление после ошибки инициализации датчиков (нормализация перекрытых датчиков)

322	Ошибка платы датчиков

323	Восстановление платы датчиков

324	Ошибка платы мотора

325	Восстановление платы мотора

400	Динамическое создание новой БД (файл старой БД, а также резервная копия повреждны или отсутствуют)

401	Восстановление БД из резервной копии

402	Создание резервной копии БД

403	Создание копии БД диагностических событий

403	Сбой создания копии БД диагностических событий

4096	Изменение настроек


